{"componentChunkName":"component---src-templates-answer-template-js","path":"/shiftLinkedListAnswer","result":{"data":{"file":{"childMarkdownRemark":{"html":"<p>So did you get this one? How'd you do?</p>\n<p>There's multiple ways of solving this problem so the solution I have might be different from the one you came up with.18th</p>\n<p>Let's start by making the problem simplier, lets only think about moving the nodes one space and not think about the negative instances.</p>\n<p>If we only have to move one node for this case, how do we do that?</p>\n<p>Well if you notice that a one node movement here pretty much just means that the last node becomes the head and the second to last node becomes the new tail</p>\n<p>Something like this:</p>\n<p>  head = 0 -> 1 -> 2 -> 3 -> 4 -> 5</p>\n<p>  1 movement over</p>\n<p>  head = 5 -> 0 -> 1 -> 2 -> 3 -> 4</p>\n<p>It's not that much work if we look at the end state like that. If we just update the head and tail the rest of the list will follow.</p>\n<p>This code does just that:</p>\n<div align=\"left\">\n<pre><code>LinkedList curr = moveOneSpot(head, negative);\nLinkedList lastNode = curr.next;\ncurr.next = null;\nlastNode.next = head;\nhead = lastNode;\nSystem.out.println(head.value);\n\n    public static LinkedList moveOneSpot(LinkedList head, Boolean negative){\n        LinkedList curr = head;\n                while(curr.next.next != null){\n                    curr = curr.next;\n                }\n            return curr;\n\n    }\n</code></pre>\n</div>\n<p>The moveOneSpot method just returns the second to last node so that we change the tail and head</p>\n<p>Now that we have that we can deal with the case of the negative numbers. In a megative number we still change the tail and head just the other way. So we can keep using the methof moveOneSpot but just adjust what replaces the head and tail.</p>\n<p>Like so:</p>\n<div align=\"left\">\n<pre><code>LinkedList curr = moveOneSpot(head, negative);\nLinkedList oldHead = head;\nhead = head.next;\noldHead.next = null;\ncurr.next.next = oldHead;\nSystem.out.println(head.value);\n</code></pre>\n</div>\n<p>Now all we have to do is track the negative so that we know when to use the former:</p>\n<div align=\"left\">\n<pre><code>public static LinkedList shiftLinkedList(LinkedList head, int k) {\n\n            int counter =0;\n            boolean negative = false;\n    while(counter != Math.abs(k)){\n                if(k &#x3C; 0) negative = true;\n                if(!negative){\n                    LinkedList curr = moveOneSpot(head, negative);\n                    LinkedList lastNode = curr.next;\n                    curr.next = null;\n                    lastNode.next = head;\n                    head = lastNode;\n                    System.out.println(head.value);\n                } else{\n                    LinkedList curr = moveOneSpot(head, negative);\n                    LinkedList oldHead = head;\n                    head = head.next;\n                    oldHead.next = null;\n                    curr.next.next = oldHead;\n                    System.out.println(head.value);\n                }\n\n                counter++;\n    }\n    return head;\n}\n\npublic static LinkedList moveOneSpot(LinkedList head, Boolean negative){\n    LinkedList curr = head;\n            while(curr.next.next != null){\n                curr = curr.next;\n            }\n        return curr;\n\n}\n</code></pre>\n</div>\n<p>We can make this code a little simplier by using the mod operator and not doing the extra work of moving nodes k times, but that a optimization you can think about that.moveOneSpot</p>\n<p>Well, seeya next time!</p>","frontmatter":{"title":"Shift Linked List ","question":"shiftlinkedlist","date":"May 18th, 2020"}}}},"pageContext":{"relativePath":"answers/shiftLinkedListAnswer.md"}}}